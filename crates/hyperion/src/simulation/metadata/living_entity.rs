// Index	Type	Meaning	Default
// 8	Byte (0)	Hand states, used to trigger blocking/eating/drinking animation.	0
// Bit mask	Meaning
// 0x01	Is hand active
// 0x02	Active hand (0 = main hand, 1 = offhand)
// 0x04	Is in riptide spin attack
// 9	Float (3)	Health	1.0
// 11	Boolean (8)	Is potion effect ambient: reduces the number of particles generated by potions to 1/5 the normal amount	false
// 12	VarInt (1)	Number of arrows in entity	0
// 13	VarInt (1)	Number of bee stingers in entity	0
// 14	Optional Position (11)	Location of the bed that the entity is currently sleeping in (Empty if it isn't sleeping)	Empty

use std::fmt::Display;

use flecs_ecs::prelude::*;
use valence_protocol::VarInt;

use super::Metadata;
use crate::define_and_register_components;

// Example usage:
define_and_register_components! {
    8, HandStates -> u8, // Hand states, used to trigger blocking/eating/drinking animation.
    9, Health -> f32,

    // 10	VarInt (1)	Potion effect color (or 0 if there is no effect)	0
    10, PotionEffectColor -> VarInt,

    // 11	Boolean (8)	Is potion effect ambient: reduces the number of particles generated by potions to 1/5 the normal amount	false
    11, IsPotionEffectAmbient -> bool,

    // 12	VarInt (1)	Number of arrows in entity	0
    12, ArrowsInEntity -> VarInt,

    // 13	VarInt (1)	Number of bee stingers in entity	0
    13, BeeStingersInEntity -> VarInt,

    // // 14	Optional Position (11)	Location of the bed that the entity is currently sleeping in (Empty if it isn't sleeping)	Empty
    // 14, SleepingPosition -> Option<glam::Vec3>,
}

impl Default for HandStates {
    fn default() -> Self {
        Self::new(0)
    }
}

impl Default for PotionEffectColor {
    fn default() -> Self {
        Self::new(VarInt(0))
    }
}

impl Default for IsPotionEffectAmbient {
    fn default() -> Self {
        Self::new(false)
    }
}

impl Default for BeeStingersInEntity {
    fn default() -> Self {
        Self::new(VarInt(0))
    }
}

impl Default for ArrowsInEntity {
    fn default() -> Self {
        Self::new(VarInt(0))
    }
}

impl Default for Health {
    fn default() -> Self {
        Self::new(20.0)
    }
}

impl Health {
    #[must_use]
    pub fn is_dead(&self) -> bool {
        self.value <= 0.0
    }

    pub fn damage(&mut self, damage: f32) {
        self.update(self.value - damage);
    }

    fn update(&mut self, value: f32) {
        self.value = value.clamp(0.0, 20.0);
    }

    pub fn heal(&mut self, heal: f32) {
        self.update(self.value + heal);
    }
}

// use unicode hearts
impl Display for Health {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        #[expect(
            clippy::cast_possible_truncation,
            reason = "we want saturating ceiling"
        )]
        let normal = usize::try_from(self.value.ceil() as isize).unwrap_or(0);

        let full_hearts = normal / 2;
        for _ in 0..full_hearts {
            write!(f, "\u{E001}")?;
        }

        if normal % 2 == 1 {
            // half heart
            write!(f, "\u{E002}")?;
        }

        Ok(())
    }
}
